#!/usr/bin/env -S deno run --allow-net --allow-run --allow-env --allow-read

import { parse } from "https://deno.land/std@0.140.0/flags/mod.ts";
import * as colors from "https://deno.land/std@0.224.0/fmt/colors.ts";

const style = {
  bold: (str: string) => colors.bold(str),
  italic: (str: string) => colors.italic(str),
  error: (str: string) => colors.bold(colors.red(str)),
  success: (str: string) => colors.bold(colors.green(str)),
  info: (str: string) => colors.cyan(str),
  warning: (str: string) => colors.yellow(str),
  dim: (str: string) => colors.dim(str),
  heading: (str: string) => colors.bold(colors.underline(colors.cyan(str))),
};

function showHelp() {
  console.log(`
${style.bold("üìã Linear CLI")}

${style.italic("A command-line interface to interact with Linear issues.")}

${style.heading("USAGE:")}
  ${style.info("linear <command> [options]")}

${style.heading("COMMANDS:")}
  ${style.info("create")}            Create a new issue.
  ${style.info("git-branch")}        Generate a git branch name from an issue.
  ${style.info("help")}              Show this help message.
  ${style.info("me")}                Display information about the current user.
  ${style.info("open")}              Open an issue in the browser.
  ${style.info("project")}           Display detailed information about a project.
  ${style.info("projects")}          List all projects in the team.
  ${style.info("ticket")}            Display detailed information about an issue.
  ${style.info("tickets")}           List your assigned issues.
  ${style.info("update")}            Update an issue's state.

${style.heading("OPTIONS:")}
  ${style.info("-i, --id=<id>")}        Specify an issue ID (e.g., "TEAM-123").
                       ${style.dim("(For: git-branch, open, update, ticket)")}
  ${style.info("-s, --state=<state>")}  The state to update the issue to.
                       ${style.dim("(For: update)")}
  ${style.info("-t, --title=<title>")}  The title for the new issue.
                       ${style.dim("(For: create)")}
  ${style.info("-c, --checkout")}       Checkout the git branch.
                       ${style.dim("(For: git-branch)")}
  ${style.info("-n, --name=<name>")}    Specify a project name.
                       ${style.dim("(For: project)")}
  ${style.info("-o, --open")}           Open the project in the browser.
                       ${style.dim("(For: project)")}
  ${style.info("-v, --verbose")}        Enable verbose output.
                       ${style.dim("(For: git-branch)")}

${style.heading("ENVIRONMENT VARIABLES:")}
  ${style.info("LINEAR_API_KEY")}    Your Linear API key.
                    ${style.dim("To get an API key, go to https://linear.app/settings/api")}
  ${style.info("LINEAR_TEAM_ID")}    Your Linear Team ID.
                    ${style.dim("To get your Team ID, go to your team's page in Linear and get it from the URL (e.g. .../team/TEAM_ID/...).")}
`);
}

interface LinearIssue {
  id: string;
  identifier: string;
  title: string;
  branchName: string;
  state: {
    id: string;
    name: string;
  };
  project?: {
    id: string;
    name: string;
  };
}

interface LinearTeam {
    id: string;
    name: string;
}

interface LinearWorkflowState {
    id: string;
    name: string;
}

class LinearClient {
  private readonly baseUrl = "https://api.linear.app/graphql";
  private readonly headers: Record<string, string>;

  constructor(apiKey: string) {
    this.headers = {
      "Authorization": apiKey,
      "Content-Type": "application/json",
    };
  }

  private async request<T>(query: string, variables?: Record<string, any>): Promise<T> {
    const response = await fetch(this.baseUrl, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify({ query, variables }),
    });

    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Linear API request failed: ${response.statusText} - ${errorBody}`);
    }

    const json = await response.json();
    if (json.errors) {
      throw new Error(`Linear API error: ${JSON.stringify(json.errors)}`);
    }
    return json.data;
  }

  async getSelf() {
    const query = `
      query Me {
        viewer {
          id
          name
          email
        }
      }
    `;
    return this.request<{ viewer: { id: string; name: string; email: string } }>(query);
  }

  async getIssue(id: string) {
    const query = `
      query Issue($id: String!) {
        issue(id: $id) {
          id
          identifier
          title
          branchName
          state {
            id
            name
          }
          project {
            id
            name
          }
        }
      }
    `;
    return this.request<{ issue: LinearIssue }>(query, { id });
  }

  async getAssignedIssues(userId: string) {
    const query = `
      query Issues($filter: IssueFilter) {
        issues(filter: $filter) {
          nodes {
            id
            identifier
            title
            branchName
            state {
              id
              name
            }
            project {
              id
              name
            }
          }
        }
      }
    `;
    const variables = {
      filter: {
        assignee: { id: { eq: userId } },
        state: { name: { nin: ["Done", "Canceled"] } },
      },
    };
    return this.request<{ issues: { nodes: LinearIssue[] } }>(query, variables);
  }

  async getLatestInProgressIssue(userId: string): Promise<LinearIssue | null> {
    const query = `
      query Issues($filter: IssueFilter, $orderBy: PaginationOrderBy) {
        issues(first: 1, filter: $filter, orderBy: $orderBy) {
          nodes {
            id
            identifier
            title
            branchName
            state {
              id
              name
            }
            project {
              id
              name
            }
          }
        }
      }
    `;
    const variables = {
      filter: {
        assignee: { id: { eq: userId } },
        state: { name: { nin: ["Done", "Canceled"] } },
      },
      orderBy: "updatedAt",
    };
    const result = await this.request<{ issues: { nodes: LinearIssue[] } }>(query, variables);
    return result.issues.nodes[0] || null;
  }

  async createIssue(title: string, teamId: string, assigneeId: string) {
    const query = `
      mutation CreateIssue($title: String!, $teamId: String!, $assigneeId: String!) {
        issueCreate(input: { title: $title, teamId: $teamId, assigneeId: $assigneeId }) {
          issue {
            id
            identifier
            title
            branchName
          }
        }
      }
    `;
    const variables = { title, teamId, assigneeId };
    return this.request<{ issueCreate: { issue: LinearIssue } }>(query, variables);
  }

  async getTeams() {
    const query = `
      query Teams {
        teams {
          nodes {
            id
            name
          }
        }
      }
    `;
    return this.request<{ teams: { nodes: LinearTeam[] } }>(query);
  }

  async getProjects(teamId: string) {
    const query = `
      query Projects($teamId: String!) {
        team(id: $teamId) {
          projects {
            nodes {
              id
              name
            }
          }
        }
      }
    `;
    return this.request<{ team: { projects: { nodes: { id: string; name: string }[] } } }>(query, { teamId });
  }

  async getProjectById(projectId: string) {
    const query = `
      query Project($projectId: String!) {
        project(id: $projectId) {
          id
          name
          description
          state
          url
          slugId
          progress
          targetDate
          startDate
          completedAt
          createdAt
          updatedAt
          lead {
            id
            name
            email
          }
          creator {
            id
            name
            email
          }
          members {
            nodes {
              id
              name
              email
            }
          }
          issues {
            nodes {
              id
              identifier
              title
              state {
                name
              }
            }
          }
        }
      }
    `;
    return this.request<{ project: any }>(query, { projectId });
  }

  async getProjectByName(teamId: string, projectName: string) {
    const query = `
      query ProjectByName($teamId: String!) {
        team(id: $teamId) {
          projects {
            nodes {
              id
              name
              description
              state
              url
              slugId
              progress
              targetDate
              startDate
              completedAt
              createdAt
              updatedAt
              lead {
                id
                name
                email
              }
              creator {
                id
                name
                email
              }
              members {
                nodes {
                  id
                  name
                  email
                }
              }
              issues {
                nodes {
                  id
                  identifier
                  title
                  state {
                    name
                  }
                }
              }
            }
          }
        }
      }
    `;
    const result = await this.request<{ team: { projects: { nodes: any[] } } }>(query, { teamId });
    const project = result.team.projects.nodes.find(p => p.name.toLowerCase() === projectName.toLowerCase());
    return project ? { project } : { project: null };
  }

  async getTeamInfo(teamId: string) {
    const query = `
      query Team($teamId: String!) {
        team(id: $teamId) {
          id
          name
          key
        }
      }
    `;
    return this.request<{ team: { id: string; name: string; key: string } }>(query, { teamId });
  }

  async getWorkflowStates(teamId: string) {
    const query = `
      query WorkflowStates($teamId: String!) {
        team(id: $teamId) {
          states {
            nodes {
              id
              name
            }
          }
        }
      }
    `;
    return this.request<{ team: { states: { nodes: LinearWorkflowState[] } } }>(query, { teamId });
  }

  async updateIssue(issueId: string, stateId: string) {
    const query = `
      mutation UpdateIssue($issueId: String!, $stateId: String!) {
        issueUpdate(id: $issueId, input: { stateId: $stateId }) {
          issue {
            id
            state {
              id
              name
            }
          }
        }
      }
    `;
    const variables = { issueId, stateId };
    return this.request(query, variables);
  }
}

function normalizeForBranchName(str: string): string {
  let normalized = str.toLowerCase();
  normalized = normalized.replace(/\s+/g, "-");
  normalized = normalized.replace(/[^a-z0-9-]/g, "");
  normalized = normalized.replace(/-+/g, "-");
  normalized = normalized.replace(/^-+|-+$/g, "");
  return normalized;
}

function generateGitBranchName(issue: LinearIssue): string {
  const key = issue.identifier;
  const content = issue.title;
  let normalizedContent = normalizeForBranchName(content);

  const prefix = `${key}`;
  const maxLength = 80;

  let branchName = `${prefix}-${normalizedContent}`;

  const availableLength = maxLength - prefix.length - 1;
  if (normalizedContent.length > availableLength) {
    normalizedContent = normalizedContent.substring(0, availableLength);
  }

  branchName = `${prefix}-${normalizedContent}`;

  return branchName;
}

async function checkoutBranch(branchName: string, verbose: boolean) {
  // First, check if the branch exists
  const checkCmd = new Deno.Command("git", { args: ["rev-parse", "--verify", branchName] });
  const { code: checkCode } = await checkCmd.output();

  const branchExists = checkCode === 0;

  let gitCmd: Deno.Command;
  if (branchExists) {
    if (verbose) console.log(`‚úÖ ${style.info(`Branch '${branchName}' already exists. Checking it out...`)}`);
    gitCmd = new Deno.Command("git", { args: ["checkout", branchName] });
  } else {
    if (verbose) console.log(`‚ú® ${style.info(`Branch '${branchName}' does not exist. Creating and checking it out...`)}`);
    gitCmd = new Deno.Command("git", { args: ["checkout", "-b", branchName] });
  }

  const { code, stderr } = await gitCmd.output();
  if (code === 0) {
    if (verbose) console.log(style.success(`‚úÖ Successfully checked out branch: '${branchName}'`));
  } else {
    console.error(`${style.error("‚ùå Error checking out branch:")} ${new TextDecoder().decode(stderr).trim()}`);
  }
}

async function openInBrowser(webUrl: string, issueId: string): Promise<void> {
    const desktopUrl = `linear://issue/${issueId}`;

    let command: string;
    let desktopArgs: string[];
    let webArgs: string[];

    switch (Deno.build.os) {
        case "darwin":
            command = "open";
            desktopArgs = [desktopUrl];
            webArgs = [webUrl];
            break;
        case "windows":
            command = "cmd";
            desktopArgs = ["/c", "start", desktopUrl];
            webArgs = ["/c", "start", webUrl];
            break;
        default:
            command = "xdg-open";
            desktopArgs = [desktopUrl];
            webArgs = [webUrl];
            break;
    }

    const p = new Deno.Command(command, { args: desktopArgs });
    const { code } = await p.output();

    if (code !== 0) {
        console.warn(style.warning("Could not open in Linear desktop app, falling back to browser."));
        const webP = new Deno.Command(command, { args: webArgs });
        const { code: webCode, stderr: webStderr } = await webP.output();
        if (webCode !== 0) {
            console.error(`${style.error("‚ùå Error opening in browser:")} ${new TextDecoder().decode(webStderr).trim()}`);
        }
    }
}

async function openProjectInBrowser(webUrl: string, projectName: string, projectId: string): Promise<void> {
    const desktopUrl = `linear://project/${projectId}/overview`;

    let command: string;
    let desktopArgs: string[];
    let webArgs: string[];

    switch (Deno.build.os) {
        case "darwin":
            command = "open";
            desktopArgs = [desktopUrl];
            webArgs = [webUrl];
            break;
        case "windows":
            command = "cmd";
            desktopArgs = ["/c", "start", desktopUrl];
            webArgs = ["/c", "start", webUrl];
            break;
        default:
            command = "xdg-open";
            desktopArgs = [desktopUrl];
            webArgs = [webUrl];
            break;
    }

    const p = new Deno.Command(command, { args: desktopArgs });
    const { code } = await p.output();

    if (code !== 0) {
        console.warn(style.warning("Could not open in Linear desktop app, falling back to browser."));
        const webP = new Deno.Command(command, { args: webArgs });
        const { code: webCode, stderr: webStderr } = await webP.output();
        if (webCode !== 0) {
            console.error(`${style.error("‚ùå Error opening in browser:")} ${new TextDecoder().decode(webStderr).trim()}`);
        }
    }
}

async function main() {
  const argv = parse(Deno.args, {
    boolean: ["checkout", "verbose", "open"],
    string: ["id", "state", "title", "name"],
    alias: {
      i: "id",
      s: "state",
      t: "title",
      c: "checkout",
      v: "verbose",
      n: "name",
      o: "open",
    },
  });

  const command = argv._[0];

  if (argv.help || argv.h || !command || command === "help") {
    showHelp();
    Deno.exit(0);
  }

  const LINEAR_API_KEY = Deno.env.get("LINEAR_API_KEY");
  const LINEAR_TEAM_ID = Deno.env.get("LINEAR_TEAM_ID");

  if (!LINEAR_API_KEY) {
    console.error(style.error("‚ùå Error: Missing LINEAR_API_KEY environment variable.\n"));
    showHelp();
    Deno.exit(1);
  }

  if (!LINEAR_TEAM_ID) {
      console.error(style.error("‚ùå Error: Missing LINEAR_TEAM_ID environment variable.\n"));
      showHelp();
      Deno.exit(1);
  }

  const client = new LinearClient(LINEAR_API_KEY);

  try {
    switch (command) {
      case "create": {
        const title = argv.title || argv._[1];
        if (!title) {
          console.error(style.error("‚ùå Please provide a title for the issue using --title."));
          Deno.exit(1);
        }
        const { viewer } = await client.getSelf();
        const { issueCreate } = await client.createIssue(title, LINEAR_TEAM_ID, viewer.id);
        console.log(style.success(`‚úÖ Successfully created issue: [${issueCreate.issue.identifier}] ${issueCreate.issue.title}`));
        break;
      }
      case "git-branch": {
        const issueId = argv.id || argv._[1];
        const verbose = argv.verbose;

        let issue: LinearIssue | null;
        if (issueId) {
            const issueResult = await client.getIssue(issueId);
            issue = issueResult.issue;
        } else {
            if (verbose) console.log(style.info("No issue ID provided, fetching your latest issue..."));
            const { viewer } = await client.getSelf();
            issue = await client.getLatestInProgressIssue(viewer.id);
        }

        if (!issue) {
          console.error(style.error(`‚ùå Could not find an issue to operate on.`));
          Deno.exit(1);
        }

        if (verbose) console.log(style.info(`\nOperating on issue: ${style.bold(`[${issue.identifier}]`)} ${issue.title}\n`));

        const branchName = generateGitBranchName(issue);
        console.log(branchName);

        if (argv.checkout) {
          await checkoutBranch(branchName, verbose);
        }
        break;
      }
      case "me": {
        const { viewer } = await client.getSelf();
        console.log(`\n${style.bold("üë§ Current User")}\n`);
        console.log(`  ${style.info("Name:")}  ${viewer.name}`);
        console.log(`  ${style.info("Email:")} ${viewer.email}`);
        console.log(`  ${style.info("ID:")}    ${viewer.id}`);
        break;
      }
      case "open": {
        let issueId = argv.id || argv._[1];

        if (!issueId) {
            console.log(style.info("No issue ID provided, fetching your latest issue..."));
            const { viewer } = await client.getSelf();
            const issue = await client.getLatestInProgressIssue(viewer.id);
            if (issue) {
                issueId = issue.identifier;
                console.log(style.info(`\nOperating on issue: ${style.bold(`[${issue.identifier}]`)} ${issue.title}\n`));
            }
        }

        if (!issueId) {
          console.error(style.error(`‚ùå Could not find an issue to operate on.`));
          Deno.exit(1);
        }

        console.log(style.info(`üöÄ Opening issue ${issueId} in your browser...`));
        const url = `https://linear.app/team/${LINEAR_TEAM_ID}/issue/${issueId}`;
        await openInBrowser(url, issueId);
        break;
      }
      case "projects": {
        const { team } = await client.getProjects(LINEAR_TEAM_ID);
        console.log(style.heading(`\nüì¶ Projects in your team:\n`));
        if (team.projects.nodes.length === 0) {
          console.log(style.info("‚ú® No projects found in this team."));
        } else {
          for (const project of team.projects.nodes) {
            console.log(`  ${style.bold(style.info(`[${project.id}]`))} ${project.name}`);
          }
        }
        break;
      }
      case "ticket": {
        const issueId = argv.id || argv._[1];
        const verbose = argv.verbose;

        let issue: LinearIssue | null;
        if (issueId) {
            const issueResult = await client.getIssue(issueId);
            issue = issueResult.issue;
        } else {
            if (verbose) console.log(style.info("No issue ID provided, fetching your latest issue..."));
            const { viewer } = await client.getSelf();
            issue = await client.getLatestInProgressIssue(viewer.id);
        }

        if (!issue) {
          console.error(style.error(`‚ùå Could not find an issue to operate on.`));
          Deno.exit(1);
        }

        console.log(`\n${style.bold(`[${issue.identifier}]`)} ${style.heading(issue.title)}\n`);
        console.log(`  ${style.info("Branch:")} ${issue.branchName}`);
        console.log(`  ${style.info("State:")}  ${issue.state.name}`);
        if (issue.project) {
          console.log(`  ${style.info("Project:")} ${issue.project.name} (${issue.project.id})`);
        }
        break;
      }
      case "tickets": {
        const { viewer } = await client.getSelf();
        const { issues } = await client.getAssignedIssues(viewer.id);
        console.log(style.heading(`\nüöÄ Assigned issues for ${viewer.name}:\n`));
        if (issues.nodes.length === 0) {
          console.log(style.info("‚ú® No assigned issues. You're all clear!"));
        } else {
          for (const issue of issues.nodes) {
            const project = issue.project ? ` ${style.dim(`(${issue.project.name} - ${issue.project.id})`)}` : "";
            console.log(`  ${style.bold(style.info(`[${issue.identifier}]`))} ${issue.title}${project}`);
          }
        }
        break;
      }
      case "update": {
        const issueId = argv.id || argv._[1];
        if (!issueId) {
          console.error(style.error("‚ùå Please provide an issue ID using --id."));
          Deno.exit(1);
        }
        const stateName = argv.state || argv._[2];
        if (!stateName) {
            console.error(style.error("‚ùå Please provide a state to update to using --state."));
            Deno.exit(1);
        }

        const { issue } = await client.getIssue(issueId);
        if (!issue) {
            console.error(style.error(`‚ùå Could not find issue: ${issueId}`));
            Deno.exit(1);
        }

        const { team } = await client.getWorkflowStates(LINEAR_TEAM_ID);
        const state = team.states.nodes.find(s => s.name.toLowerCase() === stateName.toLowerCase());

        if (!state) {
            console.error(style.error(`‚ùå Could not find state: ${stateName}`));
            Deno.exit(1);
        }

        await client.updateIssue(issue.id, state.id);
        console.log(style.success(`‚úÖ Successfully transitioned issue ${issue.identifier} to ${state.name}`));
        break;
      }
      case "project": {
        const projectName = argv.name || argv._[1];
        const shouldOpen = argv.open;

        let project: any = null;

        if (projectName) {
          // Get project by name
          const result = await client.getProjectByName(LINEAR_TEAM_ID, projectName);
          project = result.project;
        } else {
          // Get project from current ticket
          const { viewer } = await client.getSelf();
          const issue = await client.getLatestInProgressIssue(viewer.id);
          if (issue && issue.project) {
            const result = await client.getProjectById(issue.project.id);
            project = result.project;
          }
        }

        if (!project) {
          if (projectName) {
            console.error(style.error(`‚ùå Could not find project: ${projectName}`));
          } else {
            console.error(style.error(`‚ùå Could not find project for current ticket or no current ticket found.`));
          }
          Deno.exit(1);
        }

        if (shouldOpen) {
          console.log(style.info(`üöÄ Opening project ${project.name} in your browser...`));
          const { team } = await client.getTeamInfo(LINEAR_TEAM_ID);
          const projectUrl = `https://linear.app/${team.key}/project/${project.slugId}/overview`;
          await openProjectInBrowser(projectUrl, project.name, project.id);
        } else {
          // Display project information
          console.log(`\n${style.bold("üì¶ Project Details")}\n`);
          console.log(`  ${style.info("Name:")}        ${project.name}`);
          console.log(`  ${style.info("ID:")}          ${project.id}`);
          if (project.description) {
            console.log(`  ${style.info("Description:")} ${project.description}`);
          }
          console.log(`  ${style.info("State:")}       ${project.state}`);
          console.log(`  ${style.info("Progress:")}    ${Math.round(project.progress * 100)}%`);

          if (project.lead) {
            console.log(`  ${style.info("Lead:")}        ${project.lead.name} (${project.lead.email})`);
          }

          if (project.targetDate) {
            const targetDate = new Date(project.targetDate).toLocaleDateString();
            console.log(`  ${style.info("Target Date:")} ${targetDate}`);
          }

          if (project.members && project.members.nodes.length > 0) {
            console.log(`  ${style.info("Members:")}     ${project.members.nodes.length} member(s)`);
            for (const member of project.members.nodes) {
              console.log(`                   - ${member.name} (${member.email})`);
            }
          }

          if (project.issues && project.issues.nodes.length > 0) {
            console.log(`\n  ${style.info("Recent Issues:")} ${project.issues.nodes.length} issue(s)`);
            for (const issue of project.issues.nodes.slice(0, 5)) {
              console.log(`    ${style.bold(style.info(`[${issue.identifier}]`))} ${issue.title} (${issue.state.name})`);
            }
            if (project.issues.nodes.length > 5) {
              console.log(`    ... and ${project.issues.nodes.length - 5} more`);
            }
          }
        }
        break;
      }
      default: {
        console.error(style.error(`‚ùå Unknown command: ${command}\n`));
        showHelp();
        Deno.exit(1);
      }
    }
  } catch (error) {
    console.error(style.error("‚ùå Error:"), error instanceof Error ? error.message : String(error));
  }
}

main();
